use crate::{
    config::Config,
    error::Res,
    module::{Module, ModuleGraph, ModulePath},
    parser::parse_header,
    token::{Source, scan},
    types::{TypeContext, type_check_header},
};

/// Return header file contents for a given module. All exported symbols of
/// the given module are included and neatly formatted with docs.
pub fn create_header_file(module: &Module, ctx: &TypeContext) -> Result<String, String> {
    let mut s = String::new();

    s += "// This file was generated by the Koi compiler. DO NOT EDIT.\n\n";

    for (_, symbol) in module.exports() {
        s += &symbol.to_header_format(ctx);
    }

    Ok(s)
}

/// Parse and type check a header file from source string, adding it to the module graph.
pub fn read_header_file<'a>(
    modpath: ModulePath,
    src: &str,
    ctx: &mut TypeContext,
    mg: &'a mut ModuleGraph,
    config: &Config,
) -> Res<&'a Module> {
    let source = Source::new_from_string(src);
    let tokens = scan(&source, config)?;

    let (ast, source) = parse_header(source, tokens, config)?;
    type_check_header(&modpath, &source, ast, mg, ctx, config)
}
