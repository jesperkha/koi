use crate::{
    config::Config,
    error::Res,
    module::{Module, ModuleGraph, ModulePath, SymbolKind},
    parser::parse_header,
    token::{Source, scan},
    types::{TypeContext, TypeKind, type_check_header},
};

/// Return header file contents for a given module. All exported symbols of
/// the given module are included and neatly formatted with docs.
pub fn create_header_file(module: &Module, ctx: &TypeContext) -> Result<String, String> {
    let mut s = String::new();

    s += "// This file was generated by the Koi compiler. DO NOT EDIT.\n\n";

    for (name, symbol) in module.exports() {
        match &symbol.kind {
            SymbolKind::Function(func) => {
                for doc in &func.docs {
                    s += &format!("{}\n", doc);
                }

                let TypeKind::Function(ftype) = &ctx.lookup(symbol.ty).kind else {
                    panic!("expected function type");
                };

                s += &format!(
                    "func {}({}) {}\n\n",
                    name,
                    ftype
                        .params
                        .iter()
                        .map(|p| ctx.to_string(*p))
                        .collect::<Vec<_>>()
                        .join(", "),
                    ctx.to_string(ftype.ret)
                );
            }
        }
    }

    Ok(s)
}

/// Parse and type check a header file from source string, adding it to the module graph.
pub fn read_header_file<'a>(
    libname: &str,
    src: &str,
    ctx: &mut TypeContext,
    mg: &'a mut ModuleGraph,
    config: &Config,
) -> Res<&'a Module> {
    assert!(libname != "", "library name cannot be empty");
    let modpath = ModulePath::new_package(libname);

    let source = Source::new_from_string(src);
    let tokens = scan(&source, config)?;

    let (ast, source) = parse_header(source, tokens, config)?;
    type_check_header(&modpath, &source, ast, mg, ctx, config)
}
