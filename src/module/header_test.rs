use crate::{module::ModulePath, util::check_string};

#[test]
fn test_create_header_file() {
    use crate::{
        module::{ModuleGraph, create_header_file},
        types::TypeContext,
    };

    let mut ctx = TypeContext::new();
    let mut mg = ModuleGraph::new();

    let src = r#"
/// Adds one to the given integer.
pub func add_one(x int) int {
    return x
}

func nothing() { }
    "#;

    check_string(src, &mut mg, &mut ctx)
        .map_err(|err| panic!("type check error: {}", err))
        .unwrap();

    // Generate header file
    let module = mg.main();
    let header = create_header_file(&module, &ctx).unwrap();

    let expected_header = r#"// This file was generated by the Koi compiler. DO NOT EDIT.

/// Adds one to the given integer.
func add_one(i64) i64

"#;

    assert_eq!(header, expected_header);
}

#[test]
fn test_read_header_file() {
    use crate::{
        config::Config,
        module::{ModuleGraph, read_header_file},
        types::TypeContext,
    };

    let mut ctx = TypeContext::new();
    let mut mg = ModuleGraph::new();
    let config = Config::default();

    let header_src = r#"
/// Multiplies two integers.
func multiply(a int, b int) int
"#;

    let module = read_header_file(
        ModulePath::new_str("test"),
        "test.h.koi",
        header_src.as_bytes().to_owned(),
        &mut ctx,
        &mut mg,
        &config,
    )
    .map_err(|err| panic!("type check error: {}", err))
    .unwrap();

    let key = "multiply".to_owned();
    assert!(module.exports().contains_key(&key));
}
