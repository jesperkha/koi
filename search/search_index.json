{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"The Koi Programming Language","text":""},{"location":"koi/","title":"The Koi programming language","text":""},{"location":"koi/#about-koi","title":"About Koi","text":"<p>Koi is a statically typed, compiled language, made as an attempt to make a modern version of C. It keeps all the low level control and improves syntax and code writing ergonomics.</p>"},{"location":"koi/#table-of-contents","title":"Table of contents","text":""},{"location":"koi/#basic-semantics-syntax-and-more","title":"Basic semantics, syntax, and more","text":""},{"location":"koi/#hello-world","title":"Hello world","text":"<pre><code>package main\n\nfunc main() int {\n    println(\"Hello, world!\")\n    return 0\n}\n</code></pre>"},{"location":"koi/#comments","title":"Comments","text":"<pre><code>// Single line comment\n\n/*\n    Multi-line comment\n*/\n</code></pre>"},{"location":"koi/#packages","title":"Packages","text":"<p>Before you can write any code you must declare what package the file belongs to. A package declares a translation unit in compilation. Because of this, packages can be compiled seperately and used as dynamic/static libraries.</p> <pre><code>package main // Main package. Contains entry point.\n</code></pre> <pre><code>// A user package. All files in the same directory with the same\n// package declaration will be part of the same translation unit.\npackage user\n</code></pre>"},{"location":"koi/#main-function","title":"Main function","text":"<p>You must declare a main function in the main package. This is the programs entry point. The returned integer is the programs exit code.</p> <pre><code>package main\n\n// main must have this exact function signature\nfunc main() int {\n    return 0 // Exit code 0\n}\n</code></pre>"},{"location":"koi/#functions","title":"Functions","text":"<p>Functions are declared similar to Go, using the <code>func</code> keyword. The return type is specified after the parameter list. Functions that do not return a value must still declare that with the <code>void</code> return type.</p> <pre><code>// Return sum of two integers.\nfunc add(a int, b int) int {\n    return a + b\n}\n\n// Say hello. Has no return value.\nfunc sayHello() void {\n    println(\"Hello!\")\n}\n</code></pre>"},{"location":"koi/#no-semicolons","title":"No semicolons","text":"<p>Koi does not use semicolons and is therefore whitespace sensitive, to an extent. Statements end with a newline or a right brace <code>}</code>.</p> <pre><code>// Valid\nfunc double(n int) int { return n * 2 }\n\n// Error\nfunc addOne(n int) int { n += 1 return n }\n//                             ^ expected end of statement\n</code></pre>"},{"location":"koi/#strings","title":"Strings","text":"<p>Strings literals are static arrays of bytes. They are enclosed in double quotes <code>\"</code>. Character (byte) literals are written with single quotes <code>'</code>. Special characters are escaped with a backslash <code>\\</code>.</p> <pre><code>\"Hello\"\n\n\"a\" // String\n'a' // Byte\n\n'\\n' // newline\n\nlen(\"Bob\") // 3\n</code></pre>"},{"location":"koi/#numbers-and-booleans","title":"Numbers and booleans","text":"<p>Integer literals default to a 32-bit signed integer <code>i32</code>. Number literals with a decimal point default to a 32-bit float <code>f32</code>. Boolean values are either <code>true</code> or <code>false</code>. They are their own type and cannot be compared with numbers.</p> <pre><code>2   // i32\n2.0 // f32\n\ntrue == 1 // error: mismatched types in comparison\n</code></pre>"},{"location":"koi/#variables-and-constants","title":"Variables and constants","text":"<p>Variables are declared with the <code>:=</code> operator. The type is inferred from the value. Assignment uses the <code>=</code> operator. Variables can only be assigned values of its declared type. Constants are declared with the <code>::</code> operator. You can specify the type by passing it before either operator.</p> <pre><code>age := 10      // Declare variable age of type int\nname :: \"John\" // Declare a constant name with the value John.\n\nage = 11        // Assign new value to age\nname = \"David\"  // error: cannot assign to constant\n\nnumber int := 32       // Specify type in declaration\nname const string :: \"John\"  // Same but constant\n</code></pre> <p>Constant strings and arrays are put in the data section during compilation.</p> <pre><code>animal := \"Cat\" // Allcated on the stack during runtime\nanimal :: \"Dog\" // Statically stored in data section of binary\n</code></pre>"},{"location":"koi/#arrays","title":"Arrays","text":"<pre><code>// The type is inferred from the first element\nfruits := {\"Banana\", \"Apple\", \"Orange\"} // type is []string\n\n// Specify type of array two ways\nnumbers []u8 := {1, 2, 3}\nnumbers := {1 as u8, 2, 3}\n\nlen(numbers) // 3\n</code></pre>"},{"location":"koi/#structs","title":"Structs","text":"<pre><code>struct Person {\n    name string\n    age  int\n}\n\nfunc f() {\n    john := Person{name: \"John\", age: 32}\n    println(john.name) // John\n}\n</code></pre>"},{"location":"koi/#struct-methods","title":"Struct methods","text":"<pre><code>struct Dog {\n    name string\n\n    func bark() {\n        // self is a reference to this Dog instance\n        // and is available in all struct methods\n        println(\"woof woof my name is {}\", self.name)\n    }\n}\n\nfunc f() {\n    buddy := Dog{name: \"Buddy\"}\n    buddy.bark() // woof woof my name is Buddy\n}\n</code></pre> <pre><code>struct Account {\n    holder  string\n    balance f64\n    debt    f64\n\n    // Use the 'meta' keyword to make a method globally accessible through the\n    // Account type. The 'self' keyword is not available in meta methods.\n    meta func new(name string) Account {\n        return Account{\n            holder: name,\n            balance: 0,\n            debt: 0,\n        }\n    }\n}\n\nfunc f() {\n    acc := Account.new(\"James\")\n    acc.new() // error: 'new' is a meta method on 'Account' and\n              // is not available to 'Account' instances\n}\n</code></pre>"},{"location":"koi/#tuples","title":"Tuples","text":"<pre><code>tuple Podium {\n    string\n    string\n    string\n}\n\nfunc f() {\n    p := Podium(\"John\", \"Mary\", \"Bob\")\n\n    println(p.0) // John\n    println(p.1) // Mary\n    println(p.2) // Bob\n}\n</code></pre>"},{"location":"koi/#interfaces","title":"Interfaces","text":"<pre><code>interface Named {\n    name() string\n}\n\nstruct Person is Named {\n    name string\n\n    func name() string {\n        return self.name\n    }\n}\n\n// Using multiple interfaces\nstruct File is Writer, Reader, Closer {\n    ...\n}\n</code></pre>"},{"location":"koi/#error-interface","title":"Error interface","text":"<pre><code>// Special builtin interface\ninterface Error {\n    error() string\n}\n</code></pre> <pre><code>tuple SyntaxError is Error {\n    string\n    int\n\n    func error() string {\n        return fmt(\"syntax error: {}, line {}\", self.0, self.1)\n    }\n}\n\nfunc f() error {\n    throw SyntaxError(\"missing semicolon\", 21)\n}\n</code></pre> <pre><code>// Builtin Err type\ntuple Err is Error {\n    string\n\n    func error() string {\n        return self.0\n    }\n}\n</code></pre>"},{"location":"koi/#throw-and-catch","title":"Throw and catch","text":"<pre><code>// This function either returns a float or throws an error\nfunc divide(a float, b float) float | error {\n    if b == 0 {\n        throw Err(\"cannot divide by 0\")\n    }\n    return a / b\n}\n\nfunc example() {\n    // An error is raised here and we print it out.\n    // result will be given a default value\n    // (0 in this case as it is the default for float)\n    result := divide(3, 0) catch err {\n        println(\"oops, got error: {}\", err)\n    }\n}\n\nfunc example() {\n    result := divide(8, 2) // error: error must be handled\n}\n</code></pre>"},{"location":"koi/#the-and-operators","title":"The <code>?</code> and <code>??</code> operators","text":"<pre><code>func example() error {\n    // ? operator just throws the error again\n    result := divide(1, 0)?\n\n    // shorthand for this\n    result := divide(1, 0) catch err {\n        throw err\n    }\n}\n\nfunc example() error {\n    // ?? operator panics if an error is thrown\n    result := divide(1, 0)??\n\n    // shorthand for this\n    result := divide(1, 0) catch err {\n        panic(\"{}\", err)\n    }\n}\n</code></pre>"},{"location":"koi/#ownership","title":"Ownership","text":"<p>Koi uses ownership rules to improve code readability and maintance when dealing with pointers and memory. There are only a few rules that govern ownership:</p> <ol> <li>A pointer must have an owner.</li> <li>You must pass on the ownership of a pointer in the same scope you acquired it.</li> <li>You cannot assign to a variable owning a pointer before giving up ownership.</li> </ol> <p>Koi uses the <code>!</code> symbol to denote ownership of a pointer. Note that this is not a type, but rather an indicator saying \"you now own this pointer\".</p> <p>Simplest example:</p> <pre><code>func example() void {\n    // Allocate number on the heap.\n    // number now owns the pointer to that memory\n    number: *int = alloc(int, 1);\n    //          ^ note that there is no ! here because, again, *its not a type*\n\n    println(\"My favorite number is {}\", *number);\n\n    // Using ! to pass along ownership of number\n    free(number!)\n\n    *number += 1 // This will raise a compilation error as number\n                 // is used after ownership is passed on\n}\n</code></pre> <p>Explanation of rule 3:</p> <pre><code>func example() void {\n    mem := alloc([32]byte) // mem owns the pointer returned\n\n    // Error. Cannot assign to a variable before passing on ownership\n    mem = alloc([64]byte)\n\n    // Ok\n    mem = realloc(mem!, [64]byte)\n\n    // Error. Ownership of mem was never passed on\n}\n</code></pre>"},{"location":"koi/#pointer-lifetimes","title":"Pointer lifetimes","text":"<p>Ownership can be artificially created and destroyed with the respective <code>own()</code> and <code>end()</code> builtin functions. They are both 'magic' functions as they are technically disallowed by the compiler. They serve no purpose other than to open and close the ownership loop (mostly used when creating custom allocators).</p> <pre><code>// Returns the same pointer, but now owned.\nfunc own(ptr *void) *void!\n\n// Takes final ownership of a pointer and does nothing.\nfunc end(ptr *void!)\n</code></pre> <p><code>alloc()</code> and <code>free()</code> are implemented using them:</p> <pre><code>func alloc(t type) *void! {\n    // ...acquire memory using syscalls etc...\n    ptr := ...\n\n    return own(ptr)\n}\n\n// Takes final ownership of a pointer and does nothing.\nfunc free(ptr *void!) {\n    // ...mark memory as freed and do other stuff...\n\n    end(ptr)\n}\n</code></pre>"},{"location":"docs/main/","title":"Main Function","text":""},{"location":"examples/work_with_c/","title":"Working with C","text":""},{"location":"getstarted/create_project/","title":"Creating a Project","text":""},{"location":"getstarted/hello_world/","title":"Hello World","text":""}]}